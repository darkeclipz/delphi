unit Solver;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus, Vcl.Grids, Vcl.StdCtrls,
  Vcl.ComCtrls;

type
  TForm1 = class(TForm)
    OutputMemo: TMemo;
    SudokuGrid: TStringGrid;
    LoadPuzzleButton: TButton;
    SolveButton: TButton;
    Animate: TCheckBox;
    StopButton: TButton;
    procedure LoadPuzzleButtonClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure SolveButtonClick(Sender: TObject);
  private
    { Private declarations }
    procedure Init;
    procedure Log(Msg: String);
    procedure LoadPuzzle(puzzleString: String);
    procedure Search(Cell: Integer);
    function IsValidRow(RowIndex: Integer): Bool;
    function IsValidColumn(ColIndex: Integer): Bool;
    function IsValidSquare(SquareIndex: Integer): Bool;
    function IsValidPartialSolution(): Bool;
  public
    { Public declarations }
  end;

var
  Form1: TForm1;
  Grid: Array[0..80] of Integer;

const
  Squares: Array[0..8] of Array[0..8] of Integer =
  (
    (0,  1,  2,  9,  10, 11, 18, 19, 20),    // square 1
    (3,  4,  5,  12, 13, 14, 21, 22, 23),    // square 2
    (6,  7,  8,  15, 16, 17, 24, 25, 26),    // square 3
    (27, 28, 29, 36, 37, 38, 45, 46, 47),    // square 4
    (30, 31, 32, 39, 40, 41, 48, 49, 50),    // square 5
    (33, 34, 35, 42, 43, 44, 51, 52, 53),    // square 6
    (54, 55, 56, 63, 64, 65, 72, 73, 74),    // square 7
    (57, 58, 59, 66, 67, 68, 75, 76, 77),    // square 8
    (60, 61, 62, 69, 70, 71, 78, 79, 80)     // square 9
  );

  easy_puzzle: string = '530070000600195000098000060800060003400803001700020006060000280000419005000080079';

implementation

{$R *.dfm}

procedure TForm1.Log(Msg: String);
begin
  OutputMemo.Lines.Append(Msg);
end;

function FindGroupIndex(Cell: Integer): Integer;
var i, j: Integer;
begin
  for i := 0 to 8 do
    for j := 0 to 8 do
      begin
        if Squares[i, j] = Cell then
        begin
          Result := i
        end;
      end;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  LoadPuzzle(easy_puzzle);
end;

procedure TForm1.Init;
var i: Integer;
begin
  for i := 0 to 81 do
  begin
    if Grid[i] <> 0 then
      SudokuGrid.Cells[i mod 9, i div 9] := IntToStr(Grid[i])
    else
      SudokuGrid.Cells[i mod 9, i div 9] := '';
  end;
end;

procedure TForm1.LoadPuzzle(puzzleString: string);
var i: Integer;
begin
  if puzzleString.Length <> 81 then
    raise Exception.Create('Invalid puzzle string, it should contain 81 characters.');
  for i := 0 to 81 do
    Grid[i] := Ord(puzzleString[i + 1]) - 48;  // 48 is the ASCII code for 0.
  Init;
  Log('Puzzle succesfully loaded.');
end;

procedure TForm1.LoadPuzzleButtonClick(Sender: TObject);
var puzzle: String;
begin
  try
    puzzle := InputBox('Load', 'Enter a puzzle string:', '');
    if puzzle.Length > 0 then
      LoadPuzzle(puzzle);
  except on E: Exception do
    Log(E.Message);
  end;
end;

function TForm1.IsValidRow(RowIndex: Integer): Bool;
var
  i: Integer;
  digits: array[0..9] of Bool;
begin
  Result := True;
  for i := 9 * RowIndex to 9 * RowIndex + 9 do
    if digits[Grid[i]] or (Grid[i] = 0) then
      digits[Grid[i]] := True
    else
      Result := False;
end;

function TForm1.IsValidColumn(ColIndex: Integer): Bool;
var
  i: Integer;
  digits: array[0..9] of Bool;
begin
  Result := True;
  i := ColIndex;
  while i < 81 do
  begin
    if digits[Grid[i]] or (Grid[i] = 0) then
      digits[Grid[i]] := True
    else
      Result := False;
    i := i + 9
  end;
end;

function TForm1.IsValidSquare(SquareIndex: Integer): Bool;
var
  i, index: Integer;
  digits: array[0..9] of Bool;
begin
  Result := True;
  for i := 0 to 8 do
  begin
    index := Squares[SquareIndex][i];
    if digits[Grid[index]] or (Grid[i] = 0) then
      digits[Grid[index]] := True
    else
      Result := False;
  end;
end;

function TForm1.IsValidPartialSolution;
var i: Integer;
begin
  Result := True;
  for i := 0 to 8 do
    Result := Result and IsValidRow(i)
                     and IsValidColumn(i)
                     and IsValidSquare(i);
end;

procedure TForm1.Search(Cell: Integer);
var
  i: Integer;
begin
  Log('k=' + IntToStr(Cell));
  if Cell >= 81 then
  begin
    Log('Found solution!');
    Exit;
  end;
  if Grid[Cell] = 0 then
    for i := 1 to 9 do
    begin
      Grid[Cell] := i;
      if IsValidPartialSolution then Search(Cell + 1);
      Grid[cell] := 0;
    end
  else Search(Cell + 1);
end;

procedure TForm1.SolveButtonClick(Sender: TObject);
begin
  Search(0);
  Log('Start solving');
end;

end.
