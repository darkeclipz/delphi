{ Lars Rotgers, 5500355, 10-12-2019 }
unit Solver;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus, Vcl.Grids,
  Vcl.StdCtrls, Vcl.ComCtrls;

type
  TForm1 = class(TForm)
    OutputMemo: TMemo;
    SudokuGrid: TStringGrid;
    LoadPuzzleButton: TButton;
    SolveButton: TButton;
    Animate: TCheckBox;
    StopButton: TButton;
    procedure LoadPuzzleButtonClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure SolveButtonClick(Sender: TObject);
    procedure StopButtonClick(Sender: TObject);
  private
    procedure UpdateGrid;
    procedure Log(Msg: String);
    procedure LoadPuzzle(puzzleString: String);
    procedure Search(Cell: Integer);
    function IsValidRow(RowIndex: Integer): Bool;
    function IsValidColumn(ColIndex: Integer): Bool;
    function IsValidSquare(SquareIndex: Integer): Bool;
    function IsValidPartialSolution(): Bool;
    function SelectFile(): String;
    function ReadFile(path: String): String;
  public
    { Public declarations }
  end;

var
  Form1: TForm1;
  Grid: Array[0..80] of Integer;
  Stop: Bool;

const
  Squares: Array[0..8] of Array[0..8] of Integer =
  (
    (0,  1,  2,  9,  10, 11, 18, 19, 20),    // square 1
    (3,  4,  5,  12, 13, 14, 21, 22, 23),    // square 2
    (6,  7,  8,  15, 16, 17, 24, 25, 26),    // square 3
    (27, 28, 29, 36, 37, 38, 45, 46, 47),    // square 4
    (30, 31, 32, 39, 40, 41, 48, 49, 50),    // square 5
    (33, 34, 35, 42, 43, 44, 51, 52, 53),    // square 6
    (54, 55, 56, 63, 64, 65, 72, 73, 74),    // square 7
    (57, 58, 59, 66, 67, 68, 75, 76, 77),    // square 8
    (60, 61, 62, 69, 70, 71, 78, 79, 80)     // square 9
  );

  easy_puzzle: string = '5300700006001950000980000608000600034008'+
                        '03001700020006060000280000419005000080079';

implementation

{$R *.dfm}

procedure TForm1.Log(Msg: String);
begin
  OutputMemo.Lines.Append(Msg);
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  SolveButton.Enabled := False;
  //LoadPuzzle(easy_puzzle);
  StopButton.Enabled := False;
  Stop := False;
  OutputMemo.Lines.Clear;
  Log('First load a puzzle by clicking load.');
  //Log('A puzzle string format is used where the entire puzzle is stored as');
  //Log('a single string with 0 indicating an empty position.');
end;

procedure TForm1.UpdateGrid;
var i: Integer;
begin
  for i := 0 to 80 do
  begin
    if Grid[i] <> 0 then
      SudokuGrid.Cells[i mod 9, i div 9] := IntToStr(Grid[i])
    else
      SudokuGrid.Cells[i mod 9, i div 9] := '';
  end;
end;

procedure TForm1.LoadPuzzle(puzzleString: string);
var i: Integer;
begin
  if puzzleString.Length <> 81 then
    raise Exception.Create('Invalid puzzle string, it '+
      'should contain 81 characters.');
  for i := 0 to 80 do
  begin
    Grid[i] := Ord(puzzleString[i + 1]) - 48;  // 48 is the ASCII code for 0.
    if (Grid[i] < 0) or (Grid[i] > 9) then
      raise Exception.Create('Grid can only contain values of 0..9, ' +
        ' error at cell ' + IntToStr(i+1) + '.');
  end;
  UpdateGrid;
  SolveButton.Enabled := True;
  Log('Puzzle succesfully loaded.');
end;

procedure TForm1.LoadPuzzleButtonClick(Sender: TObject);
var puzzle: String;
begin
  try
    puzzle := InputBox('Load', 'Enter a puzzle string:', '');
    if puzzle.Length > 0 then
      LoadPuzzle(puzzle);
  except on E: Exception do
    Log(E.Message);
  end;
end;

function TForm1.IsValidRow(RowIndex: Integer): Bool;
var
  i: Integer;
  digits: array[0..9] of Bool;
begin
  Result := True;
  for i := 0 to 9 do
    digits[i] := False;
  for i := 9 * RowIndex to 9 * RowIndex + 8 do
  begin
    if not digits[Grid[i]] or (Grid[i] = 0) then
      digits[Grid[i]] := True
    else
      Result := False;
  end;
end;

function TForm1.IsValidColumn(ColIndex: Integer): Bool;
var
  i: Integer;
  digits: array[0..9] of Bool;
begin
  Result := True;
  for i := 0 to 9 do
    digits[i] := False;
  i := ColIndex;
  while i < 81 do
  begin
    if not digits[Grid[i]] or (Grid[i] = 0) then
      digits[Grid[i]] := True
    else
      Result := False;
    i := i + 9
  end;
end;

function TForm1.IsValidSquare(SquareIndex: Integer): Bool;
var
  i, index: Integer;
  digits: array[0..9] of Bool;
begin
  Result := True;
  for i := 0 to 9 do
    digits[i] := False;
  for i := 0 to 8 do
  begin
    index := Squares[SquareIndex][i];
    if not digits[Grid[index]] or (Grid[index] = 0) then
      digits[Grid[index]] := True
    else
      Result := False;
  end;
end;

function TForm1.IsValidPartialSolution;
var i: Integer;
begin
  Result := True;
  for i := 0 to 8 do
  begin
    Result :=     IsValidRow(i)
              and IsValidColumn(i)
              and IsValidSquare(i);
    if not Result then Exit;
  end;
end;

procedure TForm1.Search(Cell: Integer);
var
  i: Integer;
begin
  if Animate.Checked then
    UpdateGrid;
  Application.ProcessMessages;
  if Cell >= 81 then
  begin
    Log('Solution found!');
    UpdateGrid;
    Stop := True;
    Exit;
  end;
  if Grid[Cell] = 0 then
    for i := 1 to 9 do
    begin
      if Stop then
        Exit;
      Grid[Cell] := i;
      if IsValidPartialSolution then
        Search(Cell + 1);
      if not Stop then
        Grid[cell] := 0;
    end
  else Search(Cell + 1);
end;

procedure TForm1.SolveButtonClick(Sender: TObject);
begin
  OutputMemo.Lines.Clear;
  if not IsValidPartialSolution then
  begin
    Log('Loaded puzzle is not solvable.');
    Exit;
  end;
  SolveButton.Enabled := False;
  Stop := False;
  StopButton.Enabled := True;
  LoadPuzzleButton.Enabled := False;
  Log('Solving . . .   (press stop to abort)');
  Search(0);
  UpdateGrid;
  StopButton.Enabled := False;
  LoadPuzzleButton.Enabled := True;
  if not Stop then
    Log('Done solving!');
end;

procedure TForm1.StopButtonClick(Sender: TObject);
begin
  Stop := True;
  StopButton.Enabled := False;
  LoadPuzzleButton.Enabled := True;
  Log('Stopping search. The puzzle is now invalid!');
  Log('Reload the puzzle to continue.');
end;

function TForm1.SelectFile(): String;
begin
  Result := 'test.soku';
end;

function TForm1.ReadFile(path: string): String;
begin

end;


end.
